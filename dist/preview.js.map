{"version":3,"sources":["../src/withRoundTrip.ts","../src/constants.ts","../src/utils/executeHandlers.ts","../src/utils/randomId.ts","../src/utils/getResponse.ts","../src/preview.ts"],"names":[],"mappings":"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","sourcesContent":["import { addons, useChannel } from \"@storybook/preview-api\";\nimport type {\n  Renderer,\n  PartialStoryFn as StoryFunction,\n  Parameters,\n} from \"@storybook/types\";\nimport {\n  STORY_CHANGED,\n  FORCE_REMOUNT,\n  STORY_ARGS_UPDATED,\n} from \"@storybook/core-events\";\nimport { EVENTS } from \"./constants\";\nimport {\n  RequestHandler,\n  http,\n  graphql,\n  delay,\n  HttpResponse,\n  HttpHandler,\n  GraphQLHandler,\n\n} from \"msw\";\nimport { getResponse } from \"./utils/getResponse\";\n\ntype Context = {\n  [x: string]: any;\n  parameters: Parameters;\n};\n\nconst channel = addons.getChannel();\nlet INITIAL_MOUNT_STATE = true;\nlet SET_INITIAL_RESPONSES = false;\nlet responseDelay = 0;\nlet status = 200;\nlet moveTimeout: NodeJS.Timeout;\nlet emit: (eventName: string, ...args: any) => void;\n\nconst updateHandlers = () => {\n  if (!Object.keys(window.__MSW_STORYBOOK__.handlersMap).length) return;\n  if (!window.__MSW_STORYBOOK__) return;\n  const worker = window.__MSW_STORYBOOK__.worker;\n  worker.resetHandlers();\n  console.log('HANDLERS', worker.listHandlers());\n  window.__MSW_STORYBOOK__.handlers?.forEach((handler) => {\n    if (!window.__MSW_STORYBOOK__.handlersMap[handler.info.header]) return;\n    const currentResponse =\n      window.__MSW_STORYBOOK__.handlersMap[handler.info.header].response;\n    const currentHandler =\n      window.__MSW_STORYBOOK__.handlersMap[handler.info.header].handler;\n\n    console.log(\"currentResponse\", currentResponse);\n    console.log(\"currentHandler\", currentHandler);\n    if ((handler as HttpHandler).info.path) {\n      const httpHandler = handler as HttpHandler;\n      worker.use(\n        http.get(httpHandler.info.path, async () => {\n          await delay(responseDelay);\n          if (currentResponse.status !== 200)\n            return new HttpResponse(null, { status: status });\n          return HttpResponse.json(currentResponse.jsonBodyData);\n        }),\n      );\n    }\n\n    else if ((handler as GraphQLHandler).info.operationName) {\n      console.log(currentResponse);\n      const graphQLHandler = handler as GraphQLHandler;\n      worker.use(\n        graphql.query(graphQLHandler.info.operationName, ({ query, variables }) => {\n          console\n          return HttpResponse.json({...currentResponse.jsonBodyData});\n        }),\n      );\n    }\n  });\n};\n\nexport const withRoundTrip = (\n  storyFn: StoryFunction<Renderer>,\n  ctx: Context,\n) => {\n  if (!ctx.parameters.msw) return storyFn();\n\n  if (!window.__MSW_STORYBOOK__) {\n    channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n    return storyFn();\n  }\n\n  if (ctx.parameters.msw.handlers) {\n    // Get handlers from story parameters\n    if (!window.__MSW_STORYBOOK__.handlers)\n      window.__MSW_STORYBOOK__.handlers = ctx.parameters.msw\n        .handlers as RequestHandler[];\n    // Initialize handlersMap to store responses\n    if (!window.__MSW_STORYBOOK__.handlersMap)\n      window.__MSW_STORYBOOK__.handlersMap = {};\n    // Define events to listen to from the addon panel\n    emit = useChannel({\n      [EVENTS.UPDATE]: ({ key, value }) => {\n        if (key === \"delay\") {\n          clearTimeout(moveTimeout);\n          responseDelay = value;\n          updateHandlers();\n          moveTimeout = setTimeout(() => {\n            channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n          }, 500);\n        }\n        if (key === \"status\") {\n          status = value;\n          updateHandlers();\n          channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n        }\n        const responseObject = {\n          delay: responseDelay,\n          status: status,\n          responses: window.__MSW_STORYBOOK__.handlersMap,\n        };\n        console.log(responseObject);\n        emit(EVENTS.SEND, responseObject);\n      },\n      [EVENTS.UPDATE_RESPONSES]: ({ key, objectKey, objectValue }) => {\n        if (key === \"responses\") {\n          console.log('UPDATE_RESPONSES',  window.__MSW_STORYBOOK__.handlersMap[objectKey]);\n\n          window.__MSW_STORYBOOK__.handlersMap[objectKey].response={\n            ...window.__MSW_STORYBOOK__.handlersMap[objectKey].response,\n            jsonBodyData : objectValue\n          }\n\n          updateHandlers();\n          console.log(objectValue, window.__MSW_STORYBOOK__.handlersMap);\n          const responseObject = {\n            delay: responseDelay,\n            status: status,\n            responses: window.__MSW_STORYBOOK__.handlersMap,\n          };\n          emit(EVENTS.SEND, responseObject);\n          channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n        }\n      },\n      [EVENTS.RESET]: () => {\n        window.__MSW_STORYBOOK__.handlersMap = {};\n        window.__MSW_STORYBOOK__.worker.stop();\n        location.reload();\n      },\n    });\n    // If this is the first time the story is mounted, send the initial state to the addon panel\n    if (INITIAL_MOUNT_STATE) {\n      logEvents();\n      emit(EVENTS.SEND, {\n        delay: responseDelay,\n        status: status,\n        responses: window.__MSW_STORYBOOK__.handlersMap,\n      });\n      channel.on(STORY_ARGS_UPDATED, () => {\n        window.__MSW_STORYBOOK__.handlersMap = {};\n        location.reload();\n      });\n      channel.on(STORY_CHANGED, () => {\n        emit(EVENTS.SEND, {\n          status: undefined,\n          delay: undefined,\n          responses: undefined,\n        });\n        window.__MSW_STORYBOOK__.handlersMap = {};\n        window.__MSW_STORYBOOK__.worker.stop();\n        location.reload();\n      });\n      INITIAL_MOUNT_STATE = false;\n    }\n  }\n\n  return storyFn();\n};\n\n// Listen to request:match events from msw in order to build the handlersMap\nconst logEvents = () => {\n  console.log(\"logEvents\");\n  const worker = window.__MSW_STORYBOOK__.worker;\n  if (!Array.isArray(window.__MSW_STORYBOOK__.handlers)) {\n    const joinedHandlers: any = [];\n    Object.values(window.__MSW_STORYBOOK__.handlers).forEach((handler) => {\n      if (Array.isArray(handler)) joinedHandlers.push(...handler);\n      else joinedHandlers.push(handler);\n    });\n    window.__MSW_STORYBOOK__.handlers = joinedHandlers;\n  }\n\n  worker.events.on(\"request:match\", async ({ request, requestId }) => {\n    if(SET_INITIAL_RESPONSES) return;\n    console.log(\"request:match\", request, requestId);\n    let { handler, response } = await getResponse(\n      window.__MSW_STORYBOOK__.handlers || [],\n      request,\n    );\n    let responseObj = {} as {\n      jsonBodyData: JSON;\n      status: number;\n      delay: number;\n    };\n    let responseData = await response.json();\n    console.log(\"handler : response\", handler, responseData);\n    if (response && handler) {\n      if (\n        window.__MSW_STORYBOOK__.handlersMap[handler.info.header] &&\n        window.__MSW_STORYBOOK__.handlersMap[handler.info.header].response\n      ) {\n        responseObj.jsonBodyData = responseData;\n      }\n\n      window.__MSW_STORYBOOK__.handlersMap[handler.info.header] = {\n        handler: handler,\n        response: {\n          ...response,\n          jsonBodyData: responseData,\n          delay: responseDelay,\n          status: response.status,\n        },\n      };\n      updateHandlers();\n      emit(EVENTS.SEND, {\n        delay: responseDelay,\n        status: status,\n        responses: window.__MSW_STORYBOOK__.handlersMap,\n      });\n      SET_INITIAL_RESPONSES = true;\n    }\n  });\n};\n","export const ADDON_ID = \"storybook/msw-vite-addon\";\nexport const PANEL_ID = `${ADDON_ID}/panel`;\nexport const PARAM_KEY = `msw`;\n\nexport const EVENTS = {\n  SEND: `${ADDON_ID}/send`,\n  UPDATE: `${ADDON_ID}/update`,\n  UPDATE_RESPONSES: `${ADDON_ID}/update-responses`,\n  RESET: `${ADDON_ID}/reset`,\n};\n","import { RequestHandler } from \"msw\";\n\nexport interface RequestHandlerExecutionResult<\n  ParsedResult extends Record<string, unknown> | undefined,\n> {\n  handler: RequestHandler;\n  parsedResult?: ParsedResult;\n  request: Request;\n  requestId: string;\n  response?: Response;\n}\n\nexport interface HandlersExecutionResult {\n  handler: RequestHandler;\n  parsedResult?: any;\n  response?: Response;\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string;\n}\n\n/**\n * Executes the list of request handlers against the given request.\n * Returns the execution result object containing any matching request\n * handler and any mocked response it returned.\n */\nexport const executeHandlers = async <Handlers extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request;\n  requestId: string;\n  handlers: Handlers;\n  resolutionContext?: ResponseResolutionContext;\n}): Promise<HandlersExecutionResult | null> => {\n  let matchingHandler: RequestHandler | null = null;\n  let result: RequestHandlerExecutionResult<any> | null = null;\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext });\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler;\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break;\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    };\n  }\n\n  return null;\n};\n","export function randomId(): string {\n  return Math.random().toString(16).slice(2);\n}\n","import { HttpResponse, RequestHandler } from \"msw\";\nimport { executeHandlers } from \"./executeHandlers\";\nimport { randomId } from \"./randomId\";\n\nexport const getResponse = async (\n  handlers: Array<RequestHandler>,\n  request: Request,\n): Promise<\n  | {\n      handler: RequestHandler | undefined;\n      response: HttpResponse;\n    }\n  | undefined\n> => {\n  const result = await executeHandlers({\n    request,\n    requestId: randomId(),\n    handlers,\n  });\n\n  return {\n    handler: result?.handler,\n    response: result?.response,\n  };\n};\n","import type { Renderer, ProjectAnnotations } from \"@storybook/types\";\nimport { withRoundTrip } from \"./withRoundTrip\";\n\nconst preview: ProjectAnnotations<Renderer> = {\n  decorators: [withRoundTrip],\n};\n\nexport default preview;\n"]}