{"version":3,"sources":["../src/withRoundTrip.ts","../src/constants.ts","../src/utils/executeHandlers.ts","../src/utils/randomId.ts","../src/utils/getResponse.ts","../src/preview.ts"],"names":[],"mappings":"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","sourcesContent":["import { addons, useChannel } from \"@storybook/preview-api\";\nimport type {\n  Renderer,\n  PartialStoryFn as StoryFunction,\n  Parameters,\n} from \"@storybook/types\";\nimport {\n  STORY_CHANGED,\n  FORCE_REMOUNT,\n  STORY_ARGS_UPDATED,\n} from \"@storybook/core-events\";\nimport { EVENTS } from \"./constants\";\nimport {\n  RequestHandler,\n  http,\n  delay,\n  HttpResponse,\n  HttpHandler,\n  GraphQLHandler,\n  HttpRequestHandler,\n  GraphQLRequestHandler,\n} from \"msw\";\nimport { getResponse } from \"./utils/getResponse\";\n\ntype Context = {\n  [x: string]: any;\n  parameters: Parameters;\n};\n\nconst channel = addons.getChannel();\nlet INITIAL_MOUNT_STATE = true;\nlet responseDelay = 0;\nlet status = 200;\nlet moveTimeout: NodeJS.Timeout;\nlet emit: (eventName: string, ...args: any) => void;\n\nconst updateHandlers = () => {\n  if (!Object.keys(window.__MSW_STORYBOOK__.handlersMap).length) return;\n  if (!window.__MSW_STORYBOOK__) return;\n  const worker = window.__MSW_STORYBOOK__.worker;\n  worker.resetHandlers();\n  window.__MSW_STORYBOOK__.handlers?.forEach((handler) => {\n    if (!window.__MSW_STORYBOOK__.handlersMap[handler.info.header]) return;\n    const currentResponse =\n      window.__MSW_STORYBOOK__.handlersMap[handler.info.header].response;\n    const currentHandler =\n      window.__MSW_STORYBOOK__.handlersMap[handler.info.header].handler;\n\n    console.log(\"currentResponse\", currentResponse);\n    console.log(\"currentHandler\", currentHandler);\n    if ((handler as HttpHandler).info.path) {\n      const httpHandler = handler as HttpHandler;\n      worker.use(\n        http.get(httpHandler.info.path, async () => {\n          console.log(\"new httphandler\", httpHandler.info.path);\n          await delay(responseDelay);\n          if (currentResponse.status !== 200)\n            return new HttpResponse(null, { status: status });\n          return HttpResponse.json(currentResponse.jsonBodyData);\n        }),\n      );\n    }\n    //   worker.use(\n    //     http.get(handler.info.path, async () => {\n    //       await delay(responseDelay);\n    //       if (currentResponse.status !== 200)\n    //         return new HttpResponse(null, { status: status });\n    //       return HttpResponse.json(currentResponse.json);\n    //     }),\n    //   );\n    // } else if (handler.info.operationName) {\n    //   console.log(currentResponse);\n    //   // worker.use(\n    //   //   graphql.query(handler.info.operationName, async ({ query }) => {\n    //   //     await delay(responseDelay);\n    //   //     if (currentResponse.status !== 200)\n    //   //       return new HttpResponse(null, { status: status });\n\n    //   //     return HttpResponse.json(currentResponse.json);\n    //   //     // return res(\n    //   //     //   ctx.status(status),\n    //   //     //   ctx.delay(delay),\n    //   //     //   currentResponse.body.includes(\"errors\")\n    //   //     //     ? ctx.errors([...JSON.parse(currentResponse.body).errors])\n    //   //     //     : ctx.data(JSON.parse(currentResponse.body).data),\n    //   //   }),\n    //   // );\n    // }\n  });\n};\n\n// const updateHandlers = (handlers: RequestHandler[]) => {\n//   if (!handlers || !responses) return;\n//   const worker = (window as any).msw;\n//   handlers?.forEach((handler: HttpHandler) => {\n//     const currentResponse = responses[handlerResponseKey(handler)];\n//     status = currentResponse.status;\n//     const method = handler.info.method as\n//       | \"GET\"\n//       | \"HEAD\"\n//       | \"POST\"\n//       | \"PUT\"\n//       | \"HEAD\"\n//       | \"PATCH\"\n//       | \"OPTIONS\"\n//       | \"DELETE\"\n//       | RegExp;\n\n//     if (typeof method !== \"string\") {\n//       console.warn(\n//         `[MSW] Failed to retrieve the original response for the given handler. Can only retrieve original responses for handlers with a string method, RegExp is currently not supported. Offending path: ${handler.info.path}`,\n//       );\n\n//       return;\n//     }\n\n//     const methodFunction = {\n//       GET: http.get,\n//       POST: http.post,\n//       PUT: http.put,\n//       DELETE: http.delete,\n//       PATCH: http.patch,\n//       HEAD: http.head,\n//       OPTIONS: http.options,\n//     }[method];\n\n//     worker.use(\n//       methodFunction(handler.info.path, async () => {\n//         await delay(responseDelay);\n//         return HttpResponse.json(currentResponse.data, {\n//           status: currentResponse.status,\n//         });\n//       }),\n//     );\n//   });\n// };\n\n// export const withRoundTrip = (\n//   storyFn: StoryFunction<Renderer>,\n//   ctx: Context,\n// ) => {\n//   let parameters,\n//     msw: { handlers: any; originalResponses: Record<string, any> },\n//     handlers: any;\n\n//   const worker = (window as any).msw;\n\n//   parameters = ctx.parameters;\n//   if (parameters) msw = getParameter(parameters, PARAM_KEY, []);\n\n//   const emit = useChannel({\n//     [EVENTS.UPDATE]: ({ key, value }) => {\n//       if (key === \"delay\") {\n//         clearTimeout(moveTimeout);\n//         responseDelay = value;\n//         updateHandlers(handlers);\n//         moveTimeout = setTimeout(() => {\n//           channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n//         }, 300);\n//       }\n//       if (key === \"status\") {\n//         status = value;\n//         Object.keys(responses).forEach((key: any) => {\n//           responses[key].status = value;\n//         });\n//         updateHandlers(handlers);\n//         channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n//       }\n//       const responseObject: ResponseObject = {\n//         delay: responseDelay,\n//         status: status,\n//         responses: responses,\n//       };\n//       emit(EVENTS.SEND, responseObject);\n//     },\n//     [EVENTS.UPDATE_RESPONSES]: ({ key, objectKey, objectValue }) => {\n//       if (key === \"responses\") {\n//         responses[objectKey].data = objectValue;\n//         const responseObject: ResponseObject = {\n//           delay: responseDelay,\n//           status: status,\n//           responses: responses,\n//         };\n//         updateHandlers(handlers);\n//         emit(EVENTS.SEND, responseObject);\n//         channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n//       }\n//     },\n//     [EVENTS.RESET]: () => {\n//       delete (window as any).msw.originalResponses;\n//       worker.stop();\n//       location.reload();\n//     },\n//   });\n\n//   if (!msw || !worker) {\n//     emit(EVENTS.SEND, {\n//       status: undefined,\n//       delay: undefined,\n//       responses: undefined,\n//     });\n\n//     return storyFn();\n//   }\n\n//   if (INITIAL_MOUNT_STATE) {\n//     handlers = msw.handlers;\n//     responses = msw.originalResponses;\n//     updateHandlers(handlers);\n//     emit(EVENTS.SEND, { status, delay: responseDelay, responses });\n//     channel.on(STORY_ARGS_UPDATED, () => {\n//       if (ctx.viewMode === \"docs\") return;\n//       delete (window as any).msw.originalResponses;\n//       location.reload();\n//     });\n//     channel.on(STORY_CHANGED, () => {\n//       delete (window as any).msw.originalResponses;\n//       worker.stop();\n\n//       STORY_CHANGED_STATE = true;\n//       location.reload();\n//     });\n//     INITIAL_MOUNT_STATE = false;\n//     //channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n//   }\n\n//   if (STORY_CHANGED_STATE) {\n//     STORY_CHANGED_STATE = false;\n//     channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n//   }\n\n//   return storyFn();\n// };\n\nexport const withRoundTrip = (\n  storyFn: StoryFunction<Renderer>,\n  ctx: Context,\n) => {\n  if (!ctx.parameters.msw) return storyFn();\n\n  if (!window.__MSW_STORYBOOK__) {\n    channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n    return storyFn();\n  }\n\n  if (ctx.parameters.msw.handlers) {\n    // Get handlers from story parameters\n    if (!window.__MSW_STORYBOOK__.handlers)\n      window.__MSW_STORYBOOK__.handlers = ctx.parameters.msw\n        .handlers as RequestHandler[];\n    // Initialize handlersMap to store responses\n    if (!window.__MSW_STORYBOOK__.handlersMap)\n      window.__MSW_STORYBOOK__.handlersMap = {};\n    // Define events to listen to from the addon panel\n    emit = useChannel({\n      [EVENTS.UPDATE]: ({ key, value }) => {\n        if (key === \"delay\") {\n          clearTimeout(moveTimeout);\n          responseDelay = value;\n          updateHandlers();\n          moveTimeout = setTimeout(() => {\n            channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n          }, 500);\n        }\n        if (key === \"status\") {\n          status = value;\n          updateHandlers();\n          channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n        }\n        const responseObject = {\n          delay: responseDelay,\n          status: status,\n          responses: window.__MSW_STORYBOOK__.handlersMap,\n        };\n        emit(EVENTS.SEND, responseObject);\n      },\n      [EVENTS.UPDATE_RESPONSES]: ({ key, objectKey, objectValue }) => {\n        if (key === \"responses\") {\n          window.__MSW_STORYBOOK__.handlersMap[objectKey].response =\n            HttpResponse.text(JSON.stringify(objectValue));\n          updateHandlers();\n          const responseObject = {\n            delay: responseDelay,\n            status: status,\n            responses: window.__MSW_STORYBOOK__.handlersMap,\n          };\n          channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n          emit(EVENTS.SEND, responseObject);\n        }\n      },\n      [EVENTS.RESET]: () => {\n        window.__MSW_STORYBOOK__.handlersMap = {};\n        window.__MSW_STORYBOOK__.worker.stop();\n        location.reload();\n      },\n    });\n    // If this is the first time the story is mounted, send the initial state to the addon panel\n    if (INITIAL_MOUNT_STATE) {\n      console.log(\"INITIAL_MOUNT_STATE\", window.__MSW_STORYBOOK__);\n      logEvents();\n      emit(EVENTS.SEND, {\n        delay: responseDelay,\n        status: status,\n        responses: window.__MSW_STORYBOOK__.handlersMap,\n      });\n      channel.on(STORY_ARGS_UPDATED, () => {\n        window.__MSW_STORYBOOK__.handlersMap = {};\n        location.reload();\n      });\n      channel.on(STORY_CHANGED, () => {\n        emit(EVENTS.SEND, {\n          status: undefined,\n          delay: undefined,\n          responses: undefined,\n        });\n        window.__MSW_STORYBOOK__.handlersMap = {};\n        window.__MSW_STORYBOOK__.worker.stop();\n        location.reload();\n      });\n      INITIAL_MOUNT_STATE = false;\n    }\n  }\n\n  return storyFn();\n};\n\n// Listen to request:match events from msw in order to build the handlersMap\nconst logEvents = () => {\n  const worker = window.__MSW_STORYBOOK__.worker;\n  if (!Array.isArray(window.__MSW_STORYBOOK__.handlers)) {\n    const joinedHandlers: any = [];\n    Object.values(window.__MSW_STORYBOOK__.handlers).forEach((handler) => {\n      if (Array.isArray(handler)) joinedHandlers.push(...handler);\n      else joinedHandlers.push(handler);\n    });\n    window.__MSW_STORYBOOK__.handlers = joinedHandlers;\n  }\n\n  worker.events.on(\"request:match\", async ({ request, requestId }) => {\n    let { handler, response } = await getResponse(\n      window.__MSW_STORYBOOK__.handlers || [],\n      request,\n    );\n    let responseObj = {} as {\n      jsonBodyData: JSON;\n      status: number;\n      delay: number;\n    };\n    let responseData = await response.json();\n    console.log(\"handler : response\", handler, responseData);\n\n    if (response && handler) {\n      if (\n        window.__MSW_STORYBOOK__.handlersMap[handler.info.header] &&\n        window.__MSW_STORYBOOK__.handlersMap[handler.info.header].response\n      ) {\n        responseObj.jsonBodyData = responseData;\n      }\n\n      window.__MSW_STORYBOOK__.handlersMap[handler.info.header] = {\n        handler: handler,\n        response: {\n          ...response,\n          jsonBodyData: responseData,\n          delay: responseDelay,\n          status: response.status,\n        },\n      };\n      updateHandlers();\n      emit(EVENTS.SEND, {\n        delay: responseDelay,\n        status: status,\n        responses: window.__MSW_STORYBOOK__.handlersMap,\n      });\n    }\n  });\n};\n","export const ADDON_ID = \"storybook/msw-vite-addon\";\nexport const PANEL_ID = `${ADDON_ID}/panel`;\nexport const PARAM_KEY = `msw`;\n\nexport const EVENTS = {\n  SEND: `${ADDON_ID}/send`,\n  UPDATE: `${ADDON_ID}/update`,\n  UPDATE_RESPONSES: `${ADDON_ID}/update-responses`,\n  RESET: `${ADDON_ID}/reset`,\n};\n","import { RequestHandler } from \"msw\";\n\nexport interface RequestHandlerExecutionResult<\n  ParsedResult extends Record<string, unknown> | undefined,\n> {\n  handler: RequestHandler;\n  parsedResult?: ParsedResult;\n  request: Request;\n  requestId: string;\n  response?: Response;\n}\n\nexport interface HandlersExecutionResult {\n  handler: RequestHandler;\n  parsedResult?: any;\n  response?: Response;\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string;\n}\n\n/**\n * Executes the list of request handlers against the given request.\n * Returns the execution result object containing any matching request\n * handler and any mocked response it returned.\n */\nexport const executeHandlers = async <Handlers extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request;\n  requestId: string;\n  handlers: Handlers;\n  resolutionContext?: ResponseResolutionContext;\n}): Promise<HandlersExecutionResult | null> => {\n  let matchingHandler: RequestHandler | null = null;\n  let result: RequestHandlerExecutionResult<any> | null = null;\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext });\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler;\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break;\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    };\n  }\n\n  return null;\n};\n","export function randomId(): string {\n  return Math.random().toString(16).slice(2);\n}\n","import { HttpResponse, RequestHandler } from \"msw\";\nimport { executeHandlers } from \"./executeHandlers\";\nimport { randomId } from \"./randomId\";\n\nexport const getResponse = async (\n  handlers: Array<RequestHandler>,\n  request: Request,\n): Promise<\n  | {\n      handler: RequestHandler | undefined;\n      response: HttpResponse;\n    }\n  | undefined\n> => {\n  const result = await executeHandlers({\n    request,\n    requestId: randomId(),\n    handlers,\n  });\n\n  return {\n    handler: result?.handler,\n    response: result?.response,\n  };\n};\n","import type { Renderer, ProjectAnnotations } from \"@storybook/types\";\nimport { withRoundTrip } from \"./withRoundTrip\";\n\nconst preview: ProjectAnnotations<Renderer> = {\n  decorators: [withRoundTrip],\n};\n\nexport default preview;\n"]}