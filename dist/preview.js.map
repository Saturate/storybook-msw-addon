{"version":3,"sources":["../src/withRoundTrip.ts","../src/constants.ts","../src/helpers.ts","../src/preview.ts"],"names":["addons","useChannel","STORY_CHANGED","FORCE_REMOUNT","STORY_ARGS_UPDATED","ADDON_ID","PANEL_ID","PARAM_KEY","EVENTS","http","delay","HttpResponse","SEPARATOR","handlerResponseKey","handler","channel","INITIAL_MOUNT_STATE","STORY_CHANGED_STATE","responseDelay","status","responses","moveTimeout","getParameter","parameters","key","defaultValue","updateHandlers","handlers","worker","currentResponse","method","methodFunction","withRoundTrip","storyFn","ctx","msw","emit","value","responseObject","objectKey","objectValue","preview","preview_default"],"mappings":"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","sourcesContent":["import { addons, useChannel } from \"@storybook/preview-api\";\nimport type {\n  Renderer,\n  PartialStoryFn as StoryFunction,\n  Parameters,\n} from \"@storybook/types\";\nimport {\n  STORY_CHANGED,\n  FORCE_REMOUNT,\n  STORY_ARGS_UPDATED,\n} from \"@storybook/core-events\";\nimport { EVENTS, PARAM_KEY } from \"./constants\";\nimport { RequestHandler, http, delay, HttpResponse, HttpHandler } from \"msw\";\nimport { handlerResponseKey } from \"./helpers\";\n\ntype Context = {\n  [x: string]: any;\n  parameters: Parameters;\n};\n\ntype ResponseObject = {\n  [key: string]: string | number | Record<string, any>;\n};\n\nconst channel = addons.getChannel();\n\nlet INITIAL_MOUNT_STATE = true;\nlet STORY_CHANGED_STATE = false;\nlet responseDelay = 0;\nlet status = 200;\nlet responses: Record<string, any> = {};\nlet moveTimeout: any;\n\nconst getParameter = (\n  parameters: Parameters,\n  key: string,\n  defaultValue: any[]\n) => {\n  return parameters[key] || defaultValue;\n};\n\nconst updateHandlers = (handlers: RequestHandler[]) => {\n  if (!handlers || !responses) return;\n  const worker = (window as any).msw;\n  handlers?.forEach((handler: HttpHandler) => {\n    const currentResponse = responses[handlerResponseKey(handler)];\n    status = currentResponse.status;\n    const method = handler.info.method as 'GET' | 'HEAD' | 'POST' | 'PUT' | 'HEAD' | 'PATCH' | 'OPTIONS' | 'DELETE' | RegExp;\n\n    if (typeof method !== \"string\") {\n      console.warn(\n        `[MSW] Failed to retrieve the original response for the given handler. Can only retrieve original responses for handlers with a string method, RegExp is currently not supported. Offending path: ${handler.info.path}`\n      );\n\n      return;\n    }\n\n    const methodFunction = {\n      GET: http.get,\n      POST: http.post,\n      PUT: http.put,\n      DELETE: http.delete,\n      PATCH: http.patch,\n      HEAD: http.head,\n      OPTIONS: http.options,\n    }[method];\n\n    worker.use(\n      methodFunction(handler.info.path, async() => {\n\n        await delay(responseDelay);\n        return  HttpResponse.json(currentResponse.data, {status: currentResponse.status});\n      })\n    );\n  });\n};\n\nexport const withRoundTrip = (\n  storyFn: StoryFunction<Renderer>,\n  ctx: Context\n) => {\n  let parameters,\n    msw: { handlers: any; originalResponses: Record<string, any> },\n    handlers: any;\n\n  const worker = (window as any).msw;\n\n  parameters = ctx.parameters;\n  if (parameters) msw = getParameter(parameters, PARAM_KEY, []);\n\n  const emit = useChannel({\n    [EVENTS.UPDATE]: ({ key, value }) => {\n      if (key === \"delay\") {\n        clearTimeout(moveTimeout);\n        responseDelay = value;\n        updateHandlers(handlers);\n        moveTimeout = setTimeout(() => {\n          channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n        }, 300);\n      }\n      if (key === \"status\") {\n        status = value;\n        Object.keys(responses).forEach((key: any) => {\n          responses[key].status = value;\n        });\n        updateHandlers(handlers);\n        channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n      }\n      const responseObject: ResponseObject = {\n        delay: responseDelay,\n        status: status,\n        responses: responses,\n      };\n      emit(EVENTS.SEND, responseObject);\n    },\n    [EVENTS.UPDATE_RESPONSES]: ({ key, objectKey, objectValue }) => {\n      if (key === \"responses\") {\n        responses[objectKey].data = objectValue;\n        const responseObject: ResponseObject = {\n          delay: responseDelay,\n          status: status,\n          responses: responses,\n        };\n        updateHandlers(handlers);\n        emit(EVENTS.SEND, responseObject);\n        channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n      }\n    },\n    [EVENTS.RESET]: () => {\n      delete (window as any).msw.originalResponses;\n      worker.stop();\n      location.reload();\n    },\n  });\n\n  if (!msw || !worker) {\n    emit(EVENTS.SEND, {\n      status: undefined,\n      delay: undefined,\n      responses: undefined,\n    });\n\n    return storyFn();\n  }\n\n  if (INITIAL_MOUNT_STATE) {\n    handlers = msw.handlers;\n    responses = msw.originalResponses;\n    updateHandlers(handlers);\n    emit(EVENTS.SEND, { status, delay: responseDelay, responses });\n    channel.on(STORY_ARGS_UPDATED, () => {\n      if (ctx.viewMode === \"docs\") return;\n      delete (window as any).msw.originalResponses;\n      location.reload();\n    });\n    channel.on(STORY_CHANGED, () => {\n      delete (window as any).msw.originalResponses;\n      worker.stop();\n\n      STORY_CHANGED_STATE = true;\n      location.reload();\n    });\n    INITIAL_MOUNT_STATE = false;\n    //channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n  }\n\n  if (STORY_CHANGED_STATE) {\n    STORY_CHANGED_STATE = false;\n    channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n  }\n\n  return storyFn();\n};\n","export const ADDON_ID = \"storybook/msw-vite-addon\";\nexport const PANEL_ID = `${ADDON_ID}/panel`;\nexport const PARAM_KEY = `msw`;\n\nexport const EVENTS = {\n  SEND: `${ADDON_ID}/send`,\n  UPDATE: `${ADDON_ID}/update`,\n  UPDATE_RESPONSES: `${ADDON_ID}/update-responses`,\n  RESET: `${ADDON_ID}/reset`,\n};\n","import {HttpHandler} from \"msw\";\n\nconst SEPARATOR = \"__HandlerResponseKeySeparator__\";\n\nexport const handlerResponseKey = (handler: HttpHandler) => {\n  return [handler.info.method, handler.info.path].join(SEPARATOR);\n}\n\nexport const handlerResponseKeyParts = (key: string) => {\n  const [method, path] = key.split(SEPARATOR);\n\n  return { method, path };\n}\n","import type { Renderer, ProjectAnnotations } from \"@storybook/types\";\nimport { withRoundTrip } from \"./withRoundTrip\";\n\nconst preview: ProjectAnnotations<Renderer> = {\n  decorators: [withRoundTrip],\n};\n\nexport default preview;\n"]}