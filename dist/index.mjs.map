{"version":3,"sources":["../src/mswLoader.ts","../src/helpers.ts"],"names":["HttpMethods","setupWorker","SEPARATOR","handlerResponseKey","handler","worker","opt","initialize","options","getWorker","mswLoader","context","msw","viewMode","handlers","handlersList","modifiedHandlers","modifiedContext","modifyHandlersAndArgs","responses","getOriginalResponses","modifiedPath","key","originalResponses","path","method","originalRequest","originalResponse","originalData"],"mappings":"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","sourcesContent":["import {HttpHandler, HttpMethods} from \"msw\";\nimport { SetupWorker, setupWorker } from \"msw/browser\";\nimport {handlerResponseKey} from \"./helpers\";\n\nexport type SetupApi = SetupWorker;\nexport type InitializeOptions = Parameters<SetupWorker[\"start\"]>[0];\n\nexport type MswParameters = {\n  msw?: {\n    handlers: HttpHandler[],\n    originalResponses: Record<string, any>;\n  };\n};\n\ntype Context = {\n  parameters: MswParameters;\n  viewMode: string;\n  args: Record<string, any>;\n  allArgs: Record<string, any>;\n  initialArgs: Record<string, any>;\n};\n\nlet worker: SetupWorker;\nlet opt: InitializeOptions;\n\nexport const initialize = async (options?: InitializeOptions) => {\n  opt = options;\n};\n\nexport function getWorker(): SetupWorker {\n  if (worker === undefined) {\n    throw new Error(\n      `[MSW] Failed to retrieve the worker: no active worker found. Did you forget to call \"initialize\"?`,\n    );\n  }\n\n  return worker;\n}\n\nexport const mswLoader = async (context: Context) => {\n  const {\n    parameters: { msw },\n    viewMode,\n  } = context;\n  if (!msw) return;\n  if (msw.originalResponses || ((window as any).msw && viewMode !== \"docs\"))\n    return;\n\n  let worker;\n  if (viewMode === \"docs\" && (window as any).msw) {\n    worker = typeof global.process === \"undefined\" && (window as any).msw;\n  } else {\n    worker = typeof global.process === \"undefined\" && setupWorker();\n  }\n\n  if (\"handlers\" in msw && msw.handlers) {\n    let handlers = Object.values(msw.handlers)\n      .filter(Boolean)\n      .reduce(\n        (handlers, handlersList) => handlers.concat(handlersList),\n        [] as unknown[],\n      ) as HttpHandler[];\n    if (viewMode === \"docs\") {\n      const { handlers: modifiedHandlers, context: modifiedContext } =\n        modifyHandlersAndArgs(handlers, context);\n      handlers = modifiedHandlers;\n      context = modifiedContext;\n    }\n\n    if (handlers.length > 0) {\n      worker.use(...handlers);\n    }\n    if (!(window as any).msw) await worker.start(opt || {});\n    // prevents race conditions. If msw is already running, we don't need to start it again, otherwise we do and we wait for it to start before continuing to rendering stories.\n\n    (window as any).msw = worker;\n    const responses = await getOriginalResponses(handlers);\n    context.parameters.msw = {\n      ...msw,\n      originalResponses: responses,\n    };\n  }\n\n  return {};\n};\n\nconst modifyHandlersAndArgs = (handlers: any, context: Context) => {\n  handlers.forEach((handler: any) => {\n    const modifiedPath =\n      handler.info.path.replace(/\\/$/, \"\") + `/${self.crypto.randomUUID()}`;\n    Object.keys(context.args).forEach((key) => {\n      if (context.args[key] === handler.info.path) {\n        context.args[key] = modifiedPath;\n      }\n    });\n    Object.keys(context.allArgs).forEach((key) => {\n      if (context.allArgs[key] === handler.info.path) {\n        context.allArgs[key] = modifiedPath;\n      }\n    });\n    Object.keys(context.initialArgs).forEach((key) => {\n      if (context.initialArgs[key] === handler.info.path) {\n        context.initialArgs[key] = modifiedPath;\n      }\n    });\n    handler.info.header = handler.info.header.replace(\n      handler.info.path,\n      modifiedPath,\n    );\n    handler.info.path = modifiedPath;\n  });\n\n  return { handlers: handlers, context: context };\n};\n\nconst getOriginalResponses = async (handlers: HttpHandler[]) => {\n  const originalResponses = {} as Record<string, any>;\n  for (const handler of handlers) {\n    const path = handler.info.path;\n    const method = handler.info.method || HttpMethods.GET;\n\n    if (typeof path !== 'string') {\n      console.warn(\n        `[MSW] Failed to retrieve the original response for the given handler. Can only retrieve original responses for handlers with a string path, RegExp is currently not supported. Offending path: ${path}`\n      );\n      continue;\n    }\n\n    if (typeof method !== 'string') {\n      console.warn(\n        `[MSW] Failed to retrieve the original response for the given handler. Can only retrieve original responses for handlers with a string method, RegExp is currently not supported. Offending path: ${path}`\n      );\n      continue;\n    }\n\n    const originalRequest = new Request(\n      path,\n      {\n        method,\n      },\n    );\n\n    const originalResponse = await fetch(originalRequest);\n    let originalData;\n    if (!originalResponse.ok) originalData = null;\n    else originalData = await originalResponse.json();\n    originalResponses[handlerResponseKey(handler)] = {\n      data: originalData,\n      status: originalResponse.status,\n    };\n  }\n\n  return originalResponses;\n};\n","import {HttpHandler} from \"msw\";\n\nconst SEPARATOR = \"__HandlerResponseKeySeparator__\";\n\nexport const handlerResponseKey = (handler: HttpHandler) => {\n  return [handler.info.method, handler.info.path].join(SEPARATOR);\n}\n\nexport const handlerResponseKeyParts = (key: string) => {\n  const [method, path] = key.split(SEPARATOR);\n\n  return { method, path };\n}\n"]}