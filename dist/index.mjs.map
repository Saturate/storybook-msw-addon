{"version":3,"sources":["../src/mswLoader.ts"],"names":["setupWorker","worker","opt","initialize","options","getWorker","mswLoader","context","msw","viewMode","handlers","handlersList","modifiedHandlers","modifiedContext","modifyHandlersAndArgs","responses","getOriginalResponses","handler","modifiedPath","key","originalResponses","originalRequest","originalResponse","originalData"],"mappings":"AAAA,OAAsB,eAAAA,MAAmB,cAoBzC,IAAIC,EACAC,EAESC,EAAa,MAAOC,GAAgC,CAC/DF,EAAME,CACR,EAEO,SAASC,GAAyB,CACvC,GAAIJ,IAAW,OACb,MAAM,IAAI,MACR,mGACF,EAGF,OAAOA,CACT,CAEO,IAAMK,EAAY,MAAOC,GAAqB,CACnD,GAAM,CACJ,WAAY,CAAE,IAAAC,CAAI,EAClB,SAAAC,CACF,EAAIF,EAEJ,GADI,CAACC,GACDA,EAAI,mBAAuB,OAAe,KAAOC,IAAa,OAChE,OAEF,IAAIR,EAOJ,GANIQ,IAAa,QAAW,OAAe,IACzCR,EAAS,OAAO,OAAO,QAAY,KAAgB,OAAe,IAElEA,EAAS,OAAO,OAAO,QAAY,KAAeD,EAAY,EAG5D,aAAcQ,GAAOA,EAAI,SAAU,CACrC,IAAIE,EAAW,OAAO,OAAOF,EAAI,QAAQ,EACtC,OAAO,OAAO,EACd,OACC,CAACE,EAAUC,IAAiBD,EAAS,OAAOC,CAAY,EACxD,CAAC,CACH,EACF,GAAIF,IAAa,OAAQ,CACvB,GAAM,CAAE,SAAUG,EAAkB,QAASC,CAAgB,EAC3DC,EAAsBJ,EAAUH,CAAO,EACzCG,EAAWE,EACXL,EAAUM,EAGRH,EAAS,OAAS,GACpBT,EAAO,IAAI,GAAGS,CAAQ,EAElB,OAAe,KAAK,MAAMT,EAAO,MAAMC,GAAO,CAAC,CAAC,EAGrD,OAAe,IAAMD,EACtB,IAAMc,EAAY,MAAMC,EAAqBN,CAAQ,EACrDH,EAAQ,WAAW,IAAM,CACvB,GAAGC,EACH,kBAAmBO,CACrB,EAGF,MAAO,CAAC,CACV,EAEMD,EAAwB,CAACJ,EAAeH,KAC5CG,EAAS,QAASO,GAAiB,CACjC,IAAMC,EACJD,EAAQ,KAAK,KAAK,QAAQ,MAAO,EAAE,EAAI,IAAI,KAAK,OAAO,WAAW,IACpE,OAAO,KAAKV,EAAQ,IAAI,EAAE,QAASY,GAAQ,CACrCZ,EAAQ,KAAKY,CAAG,IAAMF,EAAQ,KAAK,OACrCV,EAAQ,KAAKY,CAAG,EAAID,EAExB,CAAC,EACD,OAAO,KAAKX,EAAQ,OAAO,EAAE,QAASY,GAAQ,CACxCZ,EAAQ,QAAQY,CAAG,IAAMF,EAAQ,KAAK,OACxCV,EAAQ,QAAQY,CAAG,EAAID,EAE3B,CAAC,EACD,OAAO,KAAKX,EAAQ,WAAW,EAAE,QAASY,GAAQ,CAC5CZ,EAAQ,YAAYY,CAAG,IAAMF,EAAQ,KAAK,OAC5CV,EAAQ,YAAYY,CAAG,EAAID,EAE/B,CAAC,EACDD,EAAQ,KAAK,OAASA,EAAQ,KAAK,OAAO,QACxCA,EAAQ,KAAK,KACbC,CACF,EACAD,EAAQ,KAAK,KAAOC,CACtB,CAAC,EAEM,CAAE,SAAUR,EAAU,QAASH,CAAQ,GAG1CS,EAAuB,MAAON,GAAoB,CACtD,IAAMU,EAAoB,CAAC,EAC3B,QAAWH,KAAWP,EAAU,CAC9B,IAAMW,EAAkB,IAAI,QAAQJ,EAAQ,KAAK,IAAI,EAC/CK,EAAmB,MAAM,MAAMD,CAAe,EAChDE,EACCD,EAAiB,GACjBC,EAAe,MAAMD,EAAiB,KAAK,EADtBC,EAAe,KAEzCH,EAAkBH,EAAQ,KAAK,IAAI,EAAI,CACrC,KAAMM,EACN,OAAQD,EAAiB,MAC3B,EAGF,OAAOF,CACT","sourcesContent":["import { SetupWorker, setupWorker } from \"msw/browser\";\n\nexport type SetupApi = SetupWorker;\nexport type InitializeOptions = Parameters<SetupWorker[\"start\"]>[0];\n\nexport type MswParameters = {\n  msw?: {\n    handlers: any[];\n    originalResponses: Record<string, any>;\n  };\n};\n\ntype Context = {\n  parameters: MswParameters;\n  viewMode: string;\n  args: Record<string, any>;\n  allArgs: Record<string, any>;\n  initialArgs: Record<string, any>;\n};\n\nlet worker: SetupWorker;\nlet opt: InitializeOptions;\n\nexport const initialize = async (options?: InitializeOptions) => {\n  opt = options;\n};\n\nexport function getWorker(): SetupWorker {\n  if (worker === undefined) {\n    throw new Error(\n      `[MSW] Failed to retrieve the worker: no active worker found. Did you forget to call \"initialize\"?`,\n    );\n  }\n\n  return worker;\n}\n\nexport const mswLoader = async (context: Context) => {\n  const {\n    parameters: { msw },\n    viewMode,\n  } = context;\n  if (!msw) return;\n  if (msw.originalResponses || ((window as any).msw && viewMode !== \"docs\"))\n    return;\n\n  let worker;\n  if (viewMode === \"docs\" && (window as any).msw) {\n    worker = typeof global.process === \"undefined\" && (window as any).msw;\n  } else {\n    worker = typeof global.process === \"undefined\" && setupWorker();\n  }\n\n  if (\"handlers\" in msw && msw.handlers) {\n    let handlers = Object.values(msw.handlers)\n      .filter(Boolean)\n      .reduce(\n        (handlers, handlersList) => handlers.concat(handlersList),\n        [] as unknown[],\n      );\n    if (viewMode === \"docs\") {\n      const { handlers: modifiedHandlers, context: modifiedContext } =\n        modifyHandlersAndArgs(handlers, context);\n      handlers = modifiedHandlers;\n      context = modifiedContext;\n    }\n\n    if (handlers.length > 0) {\n      worker.use(...handlers);\n    }\n    if (!(window as any).msw) await worker.start(opt || {});\n    // prevents race conditions. If msw is already running, we don't need to start it again, otherwise we do and we wait for it to start before continuing to rendering stories.\n\n    (window as any).msw = worker;\n    const responses = await getOriginalResponses(handlers);\n    context.parameters.msw = {\n      ...msw,\n      originalResponses: responses,\n    };\n  }\n\n  return {};\n};\n\nconst modifyHandlersAndArgs = (handlers: any, context: Context) => {\n  handlers.forEach((handler: any) => {\n    const modifiedPath =\n      handler.info.path.replace(/\\/$/, \"\") + `/${self.crypto.randomUUID()}`;\n    Object.keys(context.args).forEach((key) => {\n      if (context.args[key] === handler.info.path) {\n        context.args[key] = modifiedPath;\n      }\n    });\n    Object.keys(context.allArgs).forEach((key) => {\n      if (context.allArgs[key] === handler.info.path) {\n        context.allArgs[key] = modifiedPath;\n      }\n    });\n    Object.keys(context.initialArgs).forEach((key) => {\n      if (context.initialArgs[key] === handler.info.path) {\n        context.initialArgs[key] = modifiedPath;\n      }\n    });\n    handler.info.header = handler.info.header.replace(\n      handler.info.path,\n      modifiedPath,\n    );\n    handler.info.path = modifiedPath;\n  });\n\n  return { handlers: handlers, context: context };\n};\n\nconst getOriginalResponses = async (handlers: any[]) => {\n  const originalResponses = {} as Record<string, any>;\n  for (const handler of handlers) {\n    const originalRequest = new Request(handler.info.path);\n    const originalResponse = await fetch(originalRequest);\n    let originalData;\n    if (!originalResponse.ok) originalData = null;\n    else originalData = await originalResponse.json();\n    originalResponses[handler.info.path] = {\n      data: originalData,\n      status: originalResponse.status,\n    };\n  }\n\n  return originalResponses;\n};\n"]}