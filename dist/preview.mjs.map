{"version":3,"sources":["../src/withRoundTrip.ts","../src/constants.ts","../src/preview.ts"],"names":["addons","useChannel","STORY_CHANGED","FORCE_REMOUNT","STORY_ARGS_UPDATED","ADDON_ID","PANEL_ID","PARAM_KEY","EVENTS","http","delay","HttpResponse","channel","INITIAL_MOUNT_STATE","STORY_CHANGED_STATE","responseDelay","status","responses","moveTimeout","getParameter","parameters","key","defaultValue","updateHandlers","handlers","worker","handler","currentResponse","withRoundTrip","storyFn","ctx","msw","emit","value","responseObject","objectKey","objectValue","preview","preview_default"],"mappings":"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","sourcesContent":["import { addons, useChannel } from \"@storybook/preview-api\";\nimport type {\n  Renderer,\n  PartialStoryFn as StoryFunction,\n  Parameters,\n} from \"@storybook/types\";\nimport {\n  STORY_CHANGED,\n  FORCE_REMOUNT,\n  STORY_ARGS_UPDATED,\n} from \"@storybook/core-events\";\nimport { EVENTS, PARAM_KEY } from \"./constants\";\nimport { RequestHandler, http, delay, HttpResponse } from \"msw\";\n\ntype Context = {\n  [x: string]: any;\n  parameters: Parameters;\n};\n\ntype ResponseObject = {\n  [key: string]: string | number | Record<string, any>;\n};\n\nconst channel = addons.getChannel();\n\nlet INITIAL_MOUNT_STATE = true;\nlet STORY_CHANGED_STATE = false;\nlet responseDelay = 0;\nlet status = 200;\nlet responses: Record<string, any> = {};\nlet moveTimeout: any;\n\nconst getParameter = (\n  parameters: Parameters,\n  key: string,\n  defaultValue: any[]\n) => {\n  return parameters[key] || defaultValue;\n};\n\nconst updateHandlers = (handlers: RequestHandler[]) => {\n  if (!handlers || !responses) return;\n  const worker = (window as any).msw;\n  handlers?.forEach((handler: any) => {\n    const currentResponse = responses[handler.info.path];\n    status = currentResponse.status;\n    worker.use(\n      http.get(handler.info.path, async() => {\n\n        await delay(responseDelay);\n        return  HttpResponse.json(currentResponse.data, {status: currentResponse.status});\n\n       \n      })\n    );\n  });\n};\n\nexport const withRoundTrip = (\n  storyFn: StoryFunction<Renderer>,\n  ctx: Context\n) => {\n  let parameters,\n    msw: { handlers: any; originalResponses: Record<string, any> },\n    handlers: any;\n\n  const worker = (window as any).msw;\n\n  parameters = ctx.parameters;\n  if (parameters) msw = getParameter(parameters, PARAM_KEY, []);\n\n  const emit = useChannel({\n    [EVENTS.UPDATE]: ({ key, value }) => {\n      if (key === \"delay\") {\n        clearTimeout(moveTimeout);\n        responseDelay = value;\n        updateHandlers(handlers);\n        moveTimeout = setTimeout(() => {\n          channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n        }, 300);\n      }\n      if (key === \"status\") {\n        status = value;\n        Object.keys(responses).forEach((key: any) => {\n          responses[key].status = value;\n        });\n        updateHandlers(handlers);\n        channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n      }\n      const responseObject: ResponseObject = {\n        delay: responseDelay,\n        status: status,\n        responses: responses,\n      };\n      emit(EVENTS.SEND, responseObject);\n    },\n    [EVENTS.UPDATE_RESPONSES]: ({ key, objectKey, objectValue }) => {\n      if (key === \"responses\") {\n        responses[objectKey].data = objectValue;\n        const responseObject: ResponseObject = {\n          delay: responseDelay,\n          status: status,\n          responses: responses,\n        };\n        updateHandlers(handlers);\n        emit(EVENTS.SEND, responseObject);\n        channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n      }\n    },\n    [EVENTS.RESET]: () => {\n      delete (window as any).msw.originalResponses;\n      worker.stop();\n      location.reload();\n    },\n  });\n\n  if (!msw || !worker) {\n    emit(EVENTS.SEND, {\n      status: undefined,\n      delay: undefined,\n      responses: undefined,\n    });\n\n    return storyFn();\n  }\n\n  if (INITIAL_MOUNT_STATE) {\n    handlers = msw.handlers;\n    responses = msw.originalResponses;\n    updateHandlers(handlers);\n    emit(EVENTS.SEND, { status, delay: responseDelay, responses });\n    channel.on(STORY_ARGS_UPDATED, () => {\n      if (ctx.viewMode === \"docs\") return;\n      delete (window as any).msw.originalResponses;\n      location.reload();\n    });\n    channel.on(STORY_CHANGED, () => {\n      delete (window as any).msw.originalResponses;\n      worker.stop();\n\n      STORY_CHANGED_STATE = true;\n      location.reload();\n    });\n    INITIAL_MOUNT_STATE = false;\n    //channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n  }\n\n  if (STORY_CHANGED_STATE) {\n    STORY_CHANGED_STATE = false;\n    channel.emit(FORCE_REMOUNT, { storyId: ctx.id });\n  }\n\n  return storyFn();\n};\n","export const ADDON_ID = \"storybook/msw-vite-addon\";\nexport const PANEL_ID = `${ADDON_ID}/panel`;\nexport const PARAM_KEY = `msw`;\n\nexport const EVENTS = {\n  SEND: `${ADDON_ID}/send`,\n  UPDATE: `${ADDON_ID}/update`,\n  UPDATE_RESPONSES: `${ADDON_ID}/update-responses`,\n  RESET: `${ADDON_ID}/reset`,\n};\n","import type { Renderer, ProjectAnnotations } from \"@storybook/types\";\nimport { withRoundTrip } from \"./withRoundTrip\";\n\nconst preview: ProjectAnnotations<Renderer> = {\n  decorators: [withRoundTrip],\n};\n\nexport default preview;\n"]}